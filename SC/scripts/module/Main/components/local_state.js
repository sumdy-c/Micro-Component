const LocalStatePage = (S, change) => {
    
    return S(DIV).append(
        S(SPAN, '.page_title').html('Состояние: Локальное состояние'),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('4.1 Понятие контролируемого элемента'),

        textBlock([
            'Сразу стоит отметить. Micro Component считает, что локальное состояние является приоритетнее глобального, хоть вы пока не знакомы с понятиями о них.',
            'Это связяно с тем, что изначально библиотека создавалась для работы именно с этим функционалом, и уже с процессе развития смогла приобрести полезные дополнительные функции. Чем пользоваться по итогу ( и пользоваться ли вообще ) решает только пользователь библиотеки, цель данной документации лишь показать и научить инструменту, который автор считает полезным. Вам следует подготовиться, ведь понятие состояния немного меняет принципы в подходах разработки на JQuery.',
            'Давайте начнём с того, что мы изначально объявим компонент, чтобы двигаться дальше, а так же чтобы не растягивать документацию сразу познакомимся с новой для нас структурой.'
        ]),

        codeBlock(
`const s = new MicroComponent({ mutauteCSS:true, deleteNativeCSS: true }).use(['example.css']);
// новая структура
const TEST = new State();
`, 'js'),

        textBlock([
            'Мы только что объявили объект состояния, который поможет нам манипулировать DOM элементами с помощью данных. Сейчас следует дополнить рассказ о состоянии тем, что теперь вы можете полностью разделять работу с данными и работу с отображением, чего ни стандартный java script, ни оный с поддержкой библиотеки JQuery не может. Конечно, уже давно есть инструменты позволяющие это сделать, но как правило они основательны и не позволяют без негативного опыта осуществить внедрение в существующий проект, а так же по понятным причинам определяют для вас стиль вашего кода.',
        ]),

        alertBlock('UI Framework', [
            'Решение в виде Micro Component не сможет конкурировать с такими гигантами как к примеру React, Angular, Vue, Svetle и другими. Это решение разработано закрывать конкретные задачи и решать вполне конкретные проблемы. Автор настоятельно рекомендует при разработке нового большого веб-приложения использовать готовые и проверенные инструменты, однако если вам нужно построить простую страницу и вы хотите для решения этой задачи использовать jQuery - Micro Component будет для вас хорошим выбором, а так же как уже упоминалось, при поддержке проекта который построен без помощи решении перечисленных выше.',
            'Пожалуйста, выбирайте инструмент осмысленно, исходя из конкретно ваших потребностей и потребностей проекта.'
        ]),

        textBlock([
            'Прежде чем мы приступи к разговору о новой функции у элемента, давайте разберёмся в том, что такое State, хоть для тех кто уже использует популярные современные решения, догадывается в чём тут дело.',
            'На самом деле, есть большие различия в реализациях этих сущностей между Micro Component и привычного для многих состояния в мире Front-End, но реализация не означает работу, и принципы работы к радости многим не отличаются.',
            'Для тех кто не успел столкнуться, кратко в Micro Component, состояние это сложный скрытый объект который сохраняет в себе последние переданное ему значение.',
            'Когда имеется ввиду скрытый, имеется ввиду - скрыт от воздействия не пользователя, а программиста, а сам класс State который мы вызваем это интерфейс для получения к нему доступа, чтения данных и записывания новых значений.',
            'Но лучше сейчас не вдаватся в эти расплывчатые объяснения о природе этой сущности. По сути это прокси объект который имеет расширенный функционал в зоне Micro Component, давайте пока просто посмотрим как он работает',
        ]),

        codeBlock(
`const s = new MicroComponent({ mutauteCSS:true, deleteNativeCSS: true }).use(['example.css']);
// новая структура
const TEST = new State();

console.log(TEST.get()); // undefined

TEST.set('Привет, состояние!');

console.log(TEST.get()); // "Привет, состояние!";

TEST.set({
    prop: 'Я свойство!',
});
console.log(TEST.get()) // { prop: 'Я свойство!' }

// Вы можете задать первое значение в конструкторе класса State
const TEST_TWO = new State('Я Инициализированный!');

console.log(TEST_TWO.get()); // "Я Инициализированный!";

`, 'js'
        ),

        textBlock([
            'Сразу, отвечая на вопрос проницательного читателя, нет Micro Component не переизобрёл переменные. У такой с первого взгляда простой и примитивной сущности, есть важная миссия. Она является контролёром элементов DOM, давайте наконец-то посмотрим на это.'
        ]),

        codeBlock(
`const s = new MicroComponent({ mutauteCSS:true, deleteNativeCSS: true }).use(['example.css']);
const TEST = new State();

s('DIV', '.class').MCstate(TEST, (test) => {
     console.log(test) // Тут ничего нет. Даже undefined нет
}, false);
`, 'js'),

        textBlock([
            'Комментарий в коде который мы увидели это не шутка, это принцип работы который мы уже очень скоро рассмотрим, но сейчас нужно остановится на новом для нас методе.'
        ]),

        alertBlock('.MCstate', [
            'Метод который принимает в себя 3 параметра.',
            '1 - объект контроллёр. Его можно получить только создав экземпляр класса State. Остальные сущности выдадут ошибку.',
            '2 - callback, функция обратного вызова, - вызывается когда меняется значение объекта контролёра.',
            '3 - (необяз.) bool парамтер, который отвечает за вызов функции обратного вызова, когда контролёр попытался переписать данные.',
            '( false - функция будет вызвана только с новыми данными, true - функция будет вызвана сразу после попытки присвоения, то есть STATE.set(value)) )',
            
            'Должна вернуть новые инструкции или null | undefined'
        ]),

        textBlock([
            'Вы наверное уже подметили для себя интересный момент, при изменении данных в контейнере вызывается обратная функция. По сути это информация не несёт особого смысла, пока мы не попробуем написать наш элемент следуя принципам разделения отображения и работы с данными.',
            'Но сразу стоит отметить важный момент, функция в MCstate будет вызвана сразу же при получении значения, даже при инициализации. Даже если мы инициализируем его как null. Но если мы передадим undefined или оставим конструктор состояния пустым, то вызов будет опущен до первого присвоения.',
            'Давайте сразу попробуем создать контролируемый объект, а потом разберёмся как он работает:'
        ]),


        codeBlock(
`const s = new MicroComponent({ mutauteCSS:true, deleteNativeCSS: true }).use(['example.css']);
const TEST = new State('first');

// в таймере мы поменяем значение TEST через две секунды
setTimeout( () => {
    TEST.set('second');
}, 2000);

s('DIV', '.class').MCstate(TEST, function (test) {
    
    // test, это текущее состояние
    
    if(test === 'first') {
        
        // this будет содержать ссылку на 2 сущности, первая и самая важная - это target, или текущий элемент. 
        // вторая, это ссылка на сущность MCstate, она для продвинутого использования, и не будет рассмотрена в контексте данной части документации
        this.target.html('Я под контролем, и у меня зеленый фон');
        

        // тут мы отдаём инструкции в обработку Micro Component
        return '.green_background';
    
    } else {
        
        this.target.html('Прошло две секунды, и теперь у меня красный фон!');
        
        return ['-green_background', '.red_background'];
    
    };
}, false);
`, 'js'
            ),

        textBlock([
            'Перед объяснением, давайте сразу взглянем на HTML код:'
        ]),

        codeBlock(
`// то что мы сначала увидим на странице
<div class="SC_green_background-GnRoN6" sc="60839178676VZOxVK">Я под контролем, и у меня зеленый фон</div>
//когда пройдет 2 секунды, мы обнаружим изменения
<div class="SC_red_background-GnRoN6" sc="60839178676VZOxVK">Прошло две секунды, и теперь у меня красный фон!</div>
`, 'html'
        ),

        textBlock([
            'Изучите пример внимательно, при детальном рассмотрении в нём нет ничего, что могло бы вас сильно запутать, особенно если вы уже сталкивались с контролируемыми объектами в других решениях.',
            'Если у вас возникнут вопросы, вы можете задать их по адресам указанным на странице докуметации.'
        ]),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('4.2 Множественный контроль'),

        textBlock([
            'Создание состояния это не тяжёлая операция, которая могла бы сильно сказаться на производительности создаваемого ресурса, тем не менее она занимает память, а бесконечное количество состояний может вредить читаймости кодовой базы.',
            'Для решения части этих проблем, мы можем присвоить одно состояние множеству элементов. Ограничений на это действие не предусмотрено.',
            'Более того, создание допустим объекта, который может контролировать коллекцию элементов будет более предпочтительным исходя из опыта кодирования, но тут появляется проблема, что уже скоро мы получим большой объект которым довольно тяжело управлять, но еще большая проблема возникает когда мы пытаемся взглянуть на код просто со стороны. При множественном, и как правило не нужном использовании MCstate у нас возникает проблема, что в отображении расположено огромное количество функций, которые по итогу засоряют ваши компоненты.',
            'Эта проблема будет решена в главе "Глобальное состояние", сейчас нам нужно запомнить важную вещь:'
        ]),

        alertBlock('Там где это нужно', [
            'Локальное состояние нужно для точечной настройки элемента, при сложных мутациях состояний или ситуаций, когда элемент может и будет меняться в многих местах вашего проекта.'
        ]),

        textBlock([
            'Еще раз, такое позиционирование не означает что нужно начинать смешивать разные принципы разработки, мы все еще хотим разделять логику и отображение, но локальное состояние не сможет граммотно покрыть эти потребности, хоть функционально и способно на это.',
            'Теперь предлагается взглянуть на объявление множественного контроля, но это так же легко как и объявление первого:'
        ]),

        codeBlock(
`const s = new MicroComponent({ mutauteCSS:true, deleteNativeCSS: true }).use(['example.css']);

const TEST = new State(1);

s('DIV', '.class').MCstate(TEST, (test) => {
    if(test === 3) {
        return ['.on' '-off'];
    }

    if(test === 1) {
        return ['.on' '-off'];
    } 

    return ['-on' '.off'];
});

s('DIV', '.class').MCstate(TEST, (test) => {
    if(test === 3) {
        return ['.on' '-off'];
    }

    if(test === 2) {
        return ['.on' '-off'];
    }
    return ['-on' '.off'];
});
`, 'js'),

        alertBlock('Справка', [
            'Вы можете использовать в функциях и логические операторы И (&&), ИЛИ (||), оператор нулевого слияния (??) и вообще любые удобные вам проверки. "Лапша" из if else использована как самая понятная для всех контрукция, ценной удобочитаемости.'
        ]),

        textBlock([
            'Вы уже можете догадаться, что изменение значения состояния изменит и всё что он контролирует, что теперь открывает для вас новые практики кодирования.',
            'Будьте уверены в том, что состояние точно знает свои элементы, он абсолютно уверен какие из них стоит поменять. Прелесть такого подхода в гибкости и точности настройки, ибо вы можете очень глубоко настроить элемент под разные нужды. Допустим сделать очень гибкое модальное окно, которое будет разное при разных параметрах.',
        ]),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('4.3 Как делать не стоит'),

        textBlock([
            'В процессе разработки библиотеки, было следование одному маршруту. - "Не следует ограничивать инженеров в их выборе применения инструментов", это очень важный принцип который позволяет делать не узкий инструмент, а инструмент общего назначения. Не смотря на все проблемы которые мы можем получить и о которых будет сказано ниже, следует обозначить позицию более яснее,'
        ]),

        alertBlock('Справка', [
            'Micro Component, в любое время и в любом обновлении, а также при добавления кода с помощью прекрасных людей из сообщества разработчиков, будет следовать принципам "Мы не запрещаем, но рекомендуем и советуем". Это очень строгое правило, которое может быть нарушено в разумных пределах, но без ущерба для вашего общего опыта работы с библиотекой.'
        ]),

        textBlock([
            'Тем не менее, такой подход несёт не мало рисков которые могут повлиять на ваш проект не в самом лучшем ключе. Давайте для примера вспомним стилизацию, ведь у вас есть все возможности для управлением стилизацией. Вы можете удалить или не удалять контролируемые стили. Присвоить изменённый и нативный класс в один элемент. Стоит всмонить, что любой элемент который был написан ранее может быть конвертирован в элемент под контролем Micro Component фактический ценой 3-х написанных символов. Так же дела обстоят с контролируемой областью. Вы можете контролировать родителя с помощью одного экземпляра Micro Component, а его детей с помощью второго. Даже может дойти до такого:'
        ]),

        codeBlock(
`// так делать не нужно!

const S = new MicroComponent({ mutateCSS: true, deleteNativeCSS: true }).use(['test_one.css']);
const ST = new MicroComponent({ mutateCSS: true, deleteNativeCSS: true }).use(['test_two.css']);

S(ST('DIV', '.class'), '.class').html('Плохой элемент');
`, 'js'
),

        textBlock([
            'Функционально такой код будет работать. Он присвоит 2 разных класса, не смотря на то что у них одинаковые названия. Наполнение не сломается. Но при таком подходе вы путаете области видимости и Micro Component будет вынужден поставить последний контекст применённый к элементу.',
            'Тем не менее заблокировать такую реализацию было бы не совсем верно. Проекты, задачи и проблемы которые нужно решить бывают разными, так что Micro Component предупреждает, что при использовании виртуозных подходов вы будете вынуждены держать большее количество понимания работы библиотеки в голове, а иногда всё больше растягивая строчку комментария.',
            'Но автор не просто так затронул эту тему, именно в этой главе. Дело в том что с состоянием, дела обстоят еще хуже...',
            '...ладно, на самом деле не так страшно, просто очень нужно акцентировать внимание на часто просящияся такого рода реализации.'
        ]),

        codeBlock(
`// Тот кто будет читать код, и не знаком с Micro Component очень быстро запутается

const STATE = new State();

$('#wrapper').append(
    $('<div>').addClass('element').attr('id', 'identifier'),

    S('DIV').MCstate(STATE, (state) => {
        if(state) {
            $('#identifier').removeClass('element');
            return '.class';
        }
    })
);
`, 'js'
        ),
        
        textBlock([
            'Только что мы увидели такую вещь, которая при разработке была названа "Перемешиванием". Это очень опасная практика, которая ведёт к тому, что безопасные контейнейры Micro Component по результату будут "врощены" в код. Иногда, такой подход оправдан, как правило лучше завернуть элемент в свой контейнер, допустим в нашем примере проблема решается куда проще:'
        ]),

        codeBlock(
`// Теперь человек явно увидит 2 сущности в DOM

const STATE = new State();

$('#wrapper').append(
    S($('<div>')).addClass('element').MCstate(STATE, function(state) {
        if(state) {
            this.target.removeClass('element');
        }
    }),
    S('DIV').MCstate(STATE, (state) => {
        if(state) {
            return '.class';
        }
    })
);
`, 'js'
        ),
        textBlock([
            'Таким образом, мы отделили код друг от друга, сделав 2 отдельных контейнера которые уже не будут перемешаны, в данном случае еще и избавились от id атрибута, но если вы поддерживаете старый проект, лучше отказаться от лишних удалений - это может привести к неожиданным результатам.',
        ]),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('4.4 Контекст'),

        textBlock([
            'Контроллер в Micro Component тоже имеет свой контекст, но ситуация с ним в чём-то сложнее. Micro Component не привязывает к себе состояние контроллера в момент его объявления, а только после появления контролируемой области, то есть в момент привязки к элементу который данный компонент контролирует. Это позволяет вам назначать один объект состояния в разные контейнеры не обращая внимание но область, но нужно иметь ввижу, что в проектах ( особенно, которые уже поддерживаются несколько лет ), есть потребность в получении объекта состояния - в другом файле, другой части проекта. Как правило в JQuery мы искали элементы по селектору, да что уж, даже данные необходимые таскали по атрибутам!',
            'Конечно, при разработке библиотеки это нужно было учесть, поэтому существуют функции получения объектов контроллера ( и самих компонентов ) с помощью глобальных функций.',
            'Чтобы найти компонент, у вас в элементе всегда есть атрибут sc, а если не хочется его использовать или не получается достучатся до элемента можно определить область по переданному css файлу.',
            'Но с контроллером ситуация другая. Мы не сможем найти состояние контроллера на прямую, потому что нам надо извлечь его из компонента который взял состояние к себе под наблюдение. И если состояние контроллера не получилось вовремя привязать или по иным причинам не получается получить наш контроллер, то тут необходим ряд действий который позволит безопасно получать необходимые данные.',
            'Но это следует подробно разобрать после изучения глобального состояния, а этот вопрос мы решим в главе "Заключение".'
        ]),


        S(DIV, '.link_button_block').append(
            S(SPAN, '.link_button').html('Состояние: Глобальное состояние ⟶').on('click', () => {
                change('global_state');
            })
        ),

    );
}