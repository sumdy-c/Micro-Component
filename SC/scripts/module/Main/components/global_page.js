const GlobalStatePage = (S, change) => {
    return S(DIV).append(

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('5.1 Не так как раньше'),

        textBlock([
            'Название данного раздела, стало отсылкой к разделу 2.2. Действительно, с момента погружения даже в локальное состояние подход к разработке ресурса может поменяться, но с глобальным состоянием все можно поменять почти до неузнаваемости, при этом сохраняя возможность бесшовной интеграции.',
            'Стоит отметить, что глобальное состояние создавалось как дополнительная возможность, чтобы убрать негативный опыт при разростании MCstate методов, в целом вообще всех тех проблем которые мы затрагивали при изучении локального состояния. Стоит сразу сказать, что есть вещи которые Micro Component не рекомендовал делать ранее, тут будут встречатся советы по их использованию, это обусловлено тем что в глобальном состоянии код уже определён вне читаймости  JQuery кода, а значит не сможет критично ему повредить.'
        ]),

        alertBlock('State', [
            'Важно! При объявлении контролёров, пожалуйста подумайте где вы хотите их использовать. По причинам реализации, при присвоении State в область локального состояния вы не сможете отдать его в область глобального и наоборот.'
        ]),

        textBlock([
            'Перед тем как нам перейти к знакомству с данной сущностью, следует отметить, что Micro Component не предопределяет ваше поведение при написании кода с использованием инструментов заранее, такая же ситуация и с глобальным состоянием. Вы можете писать на классах используя его контекст и оперируя экземплярами своих компонентов, можете создавать функциональные компоненты, как допустим - на примере данной документации.',
            'Не теряя ваше время будем приступать к изучению, и как всегда сначала объявим наш компонент и сразу объект State:'
        ]),

        codeBlock(
`const S = new MicroComponent({ mutateCSS: true, deleteNativeCSS: true }).use(['example.css']);

// Такое объект был создан для примера. Состояние может содержать просто примитив или еще более сложный объект.
const STATE = new State({
    text: 'Hello Global!',
    arrayList: [ 
        { text: 'Me', class: '.el_start' },
        { text: 'Me', class: '.el' },
        { text: 'Me', class: '.el_end' }
    ],
    settingElement: {
        class: '.class',
        css: { display: flex }
    }
});

// Так осуществляется работа с DOM:
// 1 параметр - контролёр объявленный выше
// 2 параметр - функция рендера элементов, должна вернуть HTMLElment | null | undefined, как свой параметр содержит актуальный объект состояния и меняет элементы внутри согласно актуальности объекта 
S(STATE, (state) => {
    return S('DIV', state.settingElement.class)
                .css(state.settingElement.css)
                .text(state.text)
                .append(
                    state.arrayList.map((el) => {
                        return return S('LI', el.class).text(el.text)
                    })
                )
});

`
,'js'
        ),

        textBlock([
            'Сразу стоит отметить, что при изменении STATE, элемент который будет возвращать обратная функция так же будет мутирован, что очень сильно может напоминать шаблонизацию в популярных решениях. Однако это не совсем так. По сути это изменённый объект локального состояния для поддержки инструментов рендера элементов, которые он контролирует. Чисто технически это означает, что тоже самое можно сделать с помощью локального состояния, однако, тут есть важный момент в позиции рендера элементов и если не вдаваться в техничские детали, отличия будут хорошо видны на переданном массиве элементов.',
            'В контейнере глобального состояния будет явно сделан акцент рендера на актуальные данные и элементы которые содержаться в state.arraylist, всегда будут равны элементам в DOM, в реализиции MCstate нам нужно будет вручную отчищать массив li элементов и заново напонять его данными, что влечёт за собой много кода и малую оптимизацию.',
            'Стоит так же отметить, что STATE может хранить больше одного узла ( в данном случае как и контролёр MCstate ), поэтому вы можете хранить разные блоки страниц в одном компоненте состояния или разделять логику по отображению компонентов, о чем мы подробнее поговорим дальше, сейчас нам нужно узнать, что контролёры могут отвечать не только за возврат актуальной стилизации как в MCstate, но и отдавать целые ветви DOM дерева. Конечно компоненты написанные на чистом JQuery внутри функции рендера тоже будут отображены и прекрасно работать.'
        ]),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('5.2 Контроль за элементами'),

        textBlock([
            'Сразу стоит отметить, что создавая глобальное состояние, то есть привязывая контролёр к функции которая это делает за вас, вы так же запоминаете этот элемент. Конечно имеется ввиду контролёр. Даже если элемент удалить со страницы, состояние будет помнить о нём, его позицию в DOM ( но удаление таких элементов через стандартные функции JQuery не является хорошей практикой ).',
            'Чтобы запомнить позицию, контролёр подмешает в ваше DOM дерево дополнительный элемент, чтобы понимать где он должен отрисовать настоящий, при необходимости.'
        ]),

        alertBlock('<micro_component>', [
            'При полном удалении элемента через функцию рендера, Micro Component гарантировано создат элемент micro_component с display: none. Это нужно чтобы он знал где находится элемент, и в случае повторного рендеринга элемента смог создать его на этом месте. Если вы решите удалить элемент со страницы, ошибки не будет. Элемент будет удалён, а последующие обращения к контролёру не будут рисовать элементы на этом месте, т.к. места для привязки не было задано заранее. Если вам нужно удалить элемент, но вы не можете получить доступ к объекту состояния, попробуйте воспользоваться глобальными функциями получения объектов, которые мы рассмотрим позже, если вам не хотелось бы получать дополнительных контролёров, вы можете избрать путь css и поставить элементу display: none',
        ]),

        textBlock([
            'В данном случае это проще показать на примере, но мы сразу рассмотрим то, с чем уже знакомились в разделе Локального состояния:'
        ]),

        codeBlock(
`//обратите внимание на состояние, оно тут пустое
const STATE = new State();

// Специально попробуем реализовать код внутри функции без применения Micro Component возможностей, для наглядности
S(STATE, (state) => {
    return $('<div>').addClass('test__class').append(
        $('<input>').attr('type', 'checkbox').attr('checked', state)
    );
}),
`,'js'
        ),
        
        textBlock([
            'Вы уже можете догадаться, что произойдет - элемент не будет отрендерен так как начальное состояние не было установлено, как и в локальном состоянии, но стоит обратить внимание на то о чем мы узнали выше и заглянуть в html:'
        ]),

        codeBlock(
`<micro_component style="height: 0; width: 0; display: none;"></micro_component>
`,'html'
        ),

        textBlock([
            'Как и было сказано, элемента на странице нет, но появилась сущность в HTML, так что фактически - есть, просто конкретно вашего элемента нет, и самого элемента мы не увидим.'
        ]),

        alertBlock('SEO', [
            'При разработке данного решения, был поднят вопрос о SEO оптимизации и элемент <micro_component> вероятно плохо под неё подходит, но при более детальном рассмотрении возникла проблема, что создание существующего в спецификации HTML элемента, может быть опасно в связи с выборками по элементам которые пользователи проектов могли делать ранее, и конечно css который вероятно мог бы быть привязан к элементам и переопределять их стили. Пожалуйста, специалисты по SEO, если наличие данного элемента может критично повредить алгоритмам поисковой машины, сообщите о проблеме в отведённом месте. Будет проведена работа в этом направлении.',
            'Пока решение с пометкой "временное".'
        ]),

        textBlock([
            'Теперь нам стоит только вызвать контролёр, и мы увидим наш элемент.'
        ]),

        codeBlock(
`//обратите внимание на состояние, оно тут пустое
const STATE = new State();

// через 2 секнунды, допустим пришли данные с запроса
setTimeout(() => {
    STATE.set(true);
},2000);

// Специально попробуем реализовать код внутри функции без применения Micro Component возможностей, для наглядности
S(STATE, (state) => {
    return $('<div>').addClass('test__class').append(
        $('<input>').attr('type', 'checkbox').attr('checked', state)
    );
}),
`,'js'
        ),

codeBlock(
`<div class="test__class">
    <input type="checkbox" checked="checked">
</div>`
,'html'
        ),

        textBlock([
            'Мы полностью заменили наш элемент данными, которые мы передавали в функцию рендера. Более того, теперь каждное новое вхождение в STATE будет изменять наши элементы исходя из изменённых данных, соответственно мы сделали с вами первый полноценный контролируемый узел HTML!'
        ]),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('5.3 Компонентный подход'),
        
        textBlock([
            'С тем что мы узнали, мы можем уже создавать незавимимые контейнеры которые будут работать внутри вашего уже написаного кода JQuery. Но с таким подходом мы можем пойти дальше, чтобы еще больше улучшить наш опыт разработки. Все что показано тут, может быть внедрено в ваш проект или стать основой для нового, поэтому не стесняйтесь эксперементировать.',
            'Давайте напишем то, что в современном мире Front-End разработки называют "Функциональный компонент" и сразу оговоримся, что отличия от иных решений будет в том, что мы с легкостью можем встроить такой компонент в уже наш существующий код проекта.',
            'И для наглядности, как когда-то мы опять возьмём какую-то условную задачу, чтобы на примере похожей на реальную задачу мы смогли определить способы применения наших знаний о Micro Component и решить её.'
        ]),

        codeBlock(
`// Рассмотрите пожалуйста код, как пример.

// Инженеры бэкенда предоставили нам новый функционал, пока никак не влияющий на код в отображении.
$.ajax({
    url: './url/path/func.php',
    type: "GET"			
}).done(function (data) {})
.error((err) => {})


// Часть фронтенда которую нам предстоить переработать
$('.container').append(
    $('<p>').html('Очень важная часть страницы'),
    $('<div>').addClass('.class')
            .append(
                $('<span>').addClass('.text').html('Пожалуйста, заполните форму'),
                $('<form>')
                    .append(
                        $(<input>).attr('id', 'from_name').attr('type', 'text').attr('placeholder', 'name'),
                        $(<input>).attr('id', 'from_phone').attr('type', 'tel').attr('placeholder', 'phone')
                    ),
                $('<button>').on('click', () => {
                    $.ajax({
                        url: './url/path/send.php',
                        type: "POST",
                        data: {
                            name: $('#from_name').val(),
                            phone: $('#from_phone').val(),
                        }			
                    })
                })
            )
).appendTo('#wrapper');
`
,'js'
        ),

        textBlock([
            'Тут мы можем увидеть какой-то компонент с формой, давайте пока остановимся на этом коде, чтобы показать как мы можем решить следующую задачу:',
        ]),

        alertBlock('Задача', [
            'Пока идут данные, отобразим лоадер, при пришедших данных, где все формы NULL отобразить полную форму и сделать текст над ней красным, если какая-то часть формы пришла не как NULL, то мы не отображаем это поле ввода при этом меняем текст на "Дополните форму", цвет не меняем, а если пришло всё, то не отбражать форму, только текст с именем пользователя.'
        ]),

        textBlock([
            'уже представляете как решить эту задачу на чистом JQuery ? Или уже поняли как это сделать на Micro Component ? В любом случае, мы посмотрим как это сделать именно на Micro Component, а решение на чистом JQuery мы опустим, в связи с не желанием раздувания документации. Но если вы сможете сделать на JQuery более лаконичное и столь же ёмкое решение, то вы бы действительно поразили автора библиотеки! Давайте посмотрим что у нас получилось:'
        ]),

        codeBlock(
`// Рассмотрите пожалуйста код, как пример.

// Уже традиционная инициализация компонента.
const S = new MicroComponent({ mutateCSS: true, deleteNativeCSS: true }).use(['example.css']);


// Объявим необходимый контролёр, и наполним его данными которые нужны для инициализации
const FORM = new State({
    user: null,
    error: false,
    loading: true,
    formText: 'Пожалуйста, заполните форму',
    // тут можно сделать форму массивом и тогда перебором, просто дополняя этот объект расширять форму.
    // но пример с массивом уже имел место в этой документации, поэтому мы предоставим такой же с объектом.
    data: {
        name: null,
        phone: null
    }
});

// Теперь влияет, но как мы помним тут нет отображения.
$.ajax({
    url: './url/path/func.php',
    type: "GET"			
}).done(function (data) {
    const result = FORM.get();
    
    result.loading = false;
    // проверяем, может нам вообще нет смысла рисовать форму, исходя из условий задачи.
    if(data.name && data.phone) {
        result.user = data.name; 
        FORM.set(result);
        return;
    }

    // Тут что-то одно или всё равно null, присвоим в форму всё, а проверим рисовать или нет уже в отображении.
    result.data.name = data.name; // а тут мы доверимся инженерам бэкенда, но в реальном проекте желательно провести дополнительные проверки на пришедшие данные.
    result.data.phone = data.phone;

    // стоит проверить есть ли что-то, чтобы поменять текст
    if(result.data.name || result.data.phone) {
        formText = 'Дополните форму';
    }

    // отправили на отрисовку
    FORM.set(result);
}).error((err) => {
    const result = FORM.get();
    result.error = true;
    FORM.set(result);
});


// Часть фронтенда которую мы переработали
$('.container').append(
    $('<p>').html('Очень важная часть страницы'),
    // Cоздание контейнера с контролёром FORM 
    S(FORM, (form) => {
        
        if(from.error) {
            return $('<div>').addClass('error').html('Ошибка!');
        }


        if(form.loading === true) {
            return $('<div>').addClass('loader');
        }

        if(form.user) {
            return $('<div>').html(from.user);
        }

        const fields = {
            name: '',
            phone: '',
        };

        return $('<div>').addClass('.class')
            .append(
                $('<span>').addClass('.text').css({ color: !form.data.name && !form.data.phone ? red : black }).html(form.formText),
                $('<form>')
                    .append(
                        // Тут мы используем состояние полей, для их контролирования. 
                        // Этот материал мы рассмотрим далее, но самые внимательные уже заметили тут можно использовать рендер, можно в данном случае пропустим чтобы не усложнять пример. 
                        !form.data.name ? $(<input>).attr('id', 'from_name').attr('type', 'text').attr('placeholder', 'name').on('input', (e) => {
                            fields.name = e.target.value;
                        }) : null,
                        !form.data.phone ? $(<input>).attr('id', 'from_phone').attr('type', 'tel').attr('placeholder', 'phone').on('input', (e) => {
                            fields.phone = e.target.value;
                        }) : null
                    ),
                $('<button>').on('click', () => {
                    $.ajax({
                        url: './url/path/send.php',
                        type: "POST",
                        data: fields,
                    })
                })
            )
        )
    }).appendTo('#wrapper');
`
,'js'
        ),

        textBlock([
            'Не торопитесь в разборе кода, который вы видите как решение, там нет ничего сложного, вероятно присутствует непривычное.',
            'Самое главное что хотелось показать этим примером, что мы можем выходить на новый уровень абстракции не затрагивая уже существующей реализации, обратите внимание, что мы даже оставили атрибут ID в полях ввода, хотя они нам не нужны в этом случае мы просто стараемся не сломать то что уже было написано ( они уже могли бы быть где-то использованы ), так же хочу обратить внимание на избегание получения селекторов.'
        ]),

        alertBlock('Для начинающих', [
            'Тем кто еще мало работал с библиотекой jQuery или не работал с ней вовсе, стоит отметить, что создание контейнера с контролёром нужно для того, что бы мы могли обновлять код в нём по востребованию. Сама нативная разработка так НЕ работает, в том числе и в связке с jQuery. При нативной разработке нам пришлось бы руками в запросе или допустим вызванной там функции перерисовывать этот компонент руками!'
        ]),

        textBlock([
            'Это решение будет работать для нашей задачи, уже хорошо, но помимо этого оно обеспечило безопасный опыт взаимодействия с DOM и удобный способ организации обновления данной части веб страницы, тем не менее в Micro Component это будет считатся небольшой сущностью. Действительно вызывающе выглядит когда мы рендерим целые веб-страницы с помощью такого подхода.',
            'Они являются действительно интересными, так как там действительно получаются сложные структуры, из-за возможности вкладывать контролируемую область в другую контролируемую область.'
        ]),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('5.4 Основополагающий подход'),

        textBlock([
            'Такое определение он получил по причине создание полноценных компонентов, действительно больших частей веб-страниц или сразу целых страниц.',
            'Это, не смотря на размах уже не такая большая тема. В реальности подходы которые будут использованы в примерах ниже, уже были использованы ранее, а основные специфики работы остаются такими же. Есть ряд моментов с тем как оптимизировать рендеринг элементов, как создать структуру - но они все работают по тем же стандартам.',
            'В дальнейшем эта документация будет обрастать деталями, а этот текст который вы читаете скорее всего будет удалён. На этапе вашего ознакомления библиотека находится в тестовом режиме о чем вы могли ознакомиться на стартовой странице документации, тем не менее если вы уже попробывали или хотите использовать её в производственных целях - не переживайте. Функции которые у вас работают, будут работать так же, за исключением внутренних оптимизаций.',
            'Продолжим...'
        ]),

        alertBlock('Важно знать!', [
            'Как вы знаете, отрисовка элементов происходит после изменения контролёра. Поэтому зачастую часто обновляемые элементы стоит записать в отдельный контейнер с отдельным контролёром, чтобы обновлять конкретно его при необходимости.',
            'Тут важно соблюдать баланс между удобством использования и оптимизацией рендеринга.'
        ]),

        textBlock([
            'Давайте посмотрим на компонент такого рода:'
        ]),

        codeBlock(
`const FIRST = new State('1');
const SECOND = new State('2');

//обратите внимание, что помимо текущего состояния мы вытягиваем функцию CHILD...
S(FIRST, (first, CHILD) => {
    
    return S('DIV').html(first).append(
        //... и используем её внтури контейнера
        CHILD(SECOND, (second) => {
            return S(DIV).html(second)
        })
    );
});

S('BUTTON').html("Первая кнопка").on(click, () => {
    FIRST.set('11');
});

S('BUTTON').html("Вторая кнопка").on(click, () => {
    SECOND.set('22');
});`,
        'js'),

        textBlock([
            'В данном примере, мы только что объявили контейнер для зависимого рендеринга, то есть когда будет обновлятся состояние FIRST каждого его ребенка, а так же их детей - будет ждать обновление контейнера. Немного позже мы поговорим о приоритетности рендеринга, сейчас главное запомнить, что функция рендера - возвращает нам состояние своего контролёра и зависимую функцию рендера. Пожалуйста, обратите своё внимание, что механизм зависимой функции рендера, по функциональности схож с функцией рендера к которой вы привыкли, хоть и не является ею! В целом, для вас это не нужная информация на данном уровне погружения, она проектировалась исходя из требований, чтобы вы могли использовать её так же.',
            'Зачем это сделано ? Вы можете полностью справедливо это уточнить, так как с первого взгляда логично использовать уже имеющуюся функцию рендера элементов, как зависимую. Давайте, для начала сделаем пример для наглядности где разбёремся в этом, а потом еще раз проговорим принципы работы:'

        ]),

codeBlock(
`const PARENT = new State('data');
const CHILD = new State('second-data');
    
S(PARENT, (parent, C) => {
    console.log('Рендер основного контейнера');
    
    return S('DIV').html(test).append(
        C(CHILD, (child) => {
            console.log('Рендер завимого контейнера ( с функцией зависимости )');
            return S('DIV').html(child);
        }),

        S(CHILD, (child) => {
            console.log('Рендер НЕ завимого контейнера ( без функцией зависимости )');
            return S('DIV').html(child);
        }),
    );
});
S(BUTTON).html('РОДИТЕЛЬ').on('click', () => {
    PARENT.set("Новые данные");
});

S(BUTTON).html('ДОЧЕРНИЙ').on('click', () => {
    CHILD.set("Новые данные");
});`
,'js'
),
        textBlock([
            'Структуру создали, давайте теперь нажмём сначала на кнопку с названием "РОДИТЕЛЬ", а потом "ДОЧЕРНИЙ", и посмотрим что у нас будет отображено в консоле:'
        ]),

        codeBlock(
`// После нажатия на кнопку "РОДИТЕЛЬ"
- Рендер основного контейнера
- Рендер завимого контейнера ( с функцией зависимости )
// После нажатия на кнопку "ДОЧЕРНИЙ"
- Рендер завимого контейнера ( с функцией зависимости )
- Рендер НЕ завимого контейнера ( без функцией зависимости )`
,'console'
        ),

        textBlock([
            'Как вы уже поняли, зависимый контейнер будет перерисован при рендере родителя, а не зависимый вернёт из своего внутреннего состояния уже готовый компонет БЕЗ перерисовки. Это, как можно догадаться сделано для оптимизации отрисовки компонентов и вы вольны решать сами, что в вам нужно отрисовать, и когда.',
            'Но это не всё. Дело в том, что у зависимого контейнера могут быть свои зависимые контейнеры. Уровень вложенности рендера и его глубину вы решаете сами, автор лишь продемонстрирует работу. Возьмём наш код:'
        ]),

codeBlock(
    `const PARENT = new State('data');
    const CHILD = new State('second-data');
    const CHILD_CHILD = new State('no-data');
        
    S(PARENT, (parent, C) => {
        console.log('Рендер основного контейнера');
        
        return S('DIV').text(test).append(
            C(CHILD, (child, CC) => {
                console.log('Рендер завимого контейнера ( с функцией зависимости )');
                return S('DIV').text(child).append(
                    CC(CHILD_CHILD, (ch) => {
                        console.log('Рендер зависимого контейнера, который создавался как зависимый');
                        return S(DIV).text(ch);
                    });
                );
            }),
    
            S(CHILD, (child) => {
                console.log('Рендер НЕ завимого контейнера ( без функцией зависимости )');
                return S('DIV').text(child);
            }),
        );
    });
    
    S(BUTTON).text('РОДИТЕЛЬ').on('click', () => {
        PARENT.set("Новые данные");
    });

    S(BUTTON).text('ДОЧЕРНИЙ').on('click', () => {
        CHILD.set("Новые данные");
    });

    S(BUTTON).text('ДОЧЕРНИЙ ДОЧЕРНЕГО').on('click', () => {
        CHILD_CHILD.set("Новые данные");
    });`
    ,'js'
    ),

    codeBlock(
`// После нажатия на кнопку "РОДИТЕЛЬ"
 - Рендер основного контейнера
 - Рендер завимого контейнера ( с функцией зависимости )
 - Рендер зависимого контейнера, который создавался как зависимый
// После нажатия на кнопку "ДОЧЕРНИЙ"
- Рендер завимого контейнера ( с функцией зависимости )
- Рендер зависимого контейнера, который создавался как зависимый
- Рендер НЕ завимого контейнера ( без функцией зависимости )
// После нажатия на кнопку "ДОЧЕРНИЙ ДОЧЕРНЕГО"
- Рендер зависимого контейнера, который создавался как зависимый`
        ,'console'
    ),

    textBlock([
        'Как вы видите, вы можете оптимально расставить приоритеты рендера. Не экономьте! Иногда лучше создать еще одно состояние и разделить логику отображения, ( но это не значит, что вы должны на каждый элемент создавать свое состояние. ), чем стараться обновлять весь компонент усилиями одного контролёра.'
    ]),

    alertBlock('Приоритетность', [
        'Обратите внимание, на то что ставить как зависимость - контролёр, из компонента родителя, не самая хорошая идея. Вы нарушаете правильность построения дерева рендера и запрашиваете не оптимальные способы обновления DOM. Обратите внимание, такое использование говорит о вероятно неверном представлении данных или построении логики отображения.'
    ]),

    S(SPAN, ['.big_text_size', '.page_sub_title']).html('5.5 Зависимости рендеринга'),

    textBlock([
        'Сразу стоит сказать, что создание веб ресурса бывает сложной задачей. Конечно, уже те кто дочитал до этого момента сможет создать или более компетентно поддерживать свои проекты, но всё же бывают ситуации когда данных инструментов будет не хватать. Она будет возникать в любом случае, но есть очевидные вещи которые сложно пропустить мимо или отмахнуться с причиной узкого и редкого использования.',
        'И при создании функционала Micro Component ( и вероятно в дальнешем ) возникали уточнения по поводу полноты предоставляемых возможностей, тем или иным инструментом. Это явно коснулось и глобального состояния.',
        'Вопрос был прост, всегда ли удобно хранить всю информацию о компоненте лишь в одном контролёре ? Отрицательный ответ был быстро найден и родилась идея зависимостей. Давайте перейдём к коду котрый мы уже использовали, и на его примере попробуем разобраться как это работает:'
    ]),

    codeBlock(
`const NAME = new State('Name');
const PHONE = new State('');
            
S(NAME, (name, C) => {
    // почему так, мы поговорим немного позднее
    const phone = PHONE.get();
    return S('DIV').text(name + phone).append();
}, [PHONE]);

S(BUTTON).text('PHONE').on('click', () => {
    PHONE.set("10-00-00");
});
`,'js'),

    textBlock([
        'Как вы можете увидеть, у нас есть контролёр который отдаёт имя. Он нормально отработает и отдаст информацию. А теперь допустим, что нам нужен телефон, но нам очень не удобно его записывать в контролёр с именем или нет желания вытягивать из контролёра с телефоном.',
        'Решение вроде проще чем кажется, записать в контролёр телефон и после этого, вызвать контролёр с именем. Такой подход имеет право на жизнь, но он вредит читаемости кода. Так же представьте, что вам нужно обновить 54 контейнера с телефоном и для этого вызывать каждый контролёр для обновления отдельно - это уже явно не кажется таким хорошим подходом.',
        'Для этих целей был введен массив зависимости рендера, он передаётся 3-им параметром и отвечает за перерисовку компонента. В примере выше, при нажатии на кнопку PHONE, контейнер с контролёром NAME обновится, не смотря на то что сам контролёр NAME никогда не вызывался, соответственно это элегантно и просто позволит записать данные о телефоне туда, куда мы определили их ранее, и в каждый контейнер с выставленной зависимостью.'
    ]),

    );
}