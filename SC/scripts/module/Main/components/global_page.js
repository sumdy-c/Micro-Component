const GlobalStatePage = (S, change, HI) => {
    
    const TEST = new State('Состояние:'); //Глобальное состояние
    console.log(HI.get());
    return S(DIV).append(
       
        S(TEST, (test) => {
            return S(SPAN, '.page_title').html(test + ' ' + HI.get().text);
        }),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('5.1 Не так как раньше'),

        textBlock([
            'Название данного раздела, стало отсылкой к разделу 2.2. Действительно, с момента погружения даже в локальное состояние подход к разработке ресурса может поменяться, но с глобальным состоянием все можно поменять почти до неузнаваемости, при этом сохраняя возможность бесшовной интеграции.',
            'Стоит отметить, что глобальное состояние создавалось как дополнительная возможность, чтобы убрать негативный опыт при разростании MCstate методов, в целом всех тех проблем которые мы затрагивали при изучении локального состояния. Стоит сразу сказать, что есть вещи которые Micro Component не рекомендовал делать ранее, тут будут встречатся советы по их использованию, это обусловлено тем что в глобальном состоянии код уже определён вне читаймости  JQuery кода, а значит не сможет критично повредить читаемости.'
        ]),

        alertBlock('State', [
            'Важно! При объявлении контролёров, пожалуйста подумайте где вы хотите их использовать. По причинам реализации, при присвоении State в область локального состояния вы не сможете отдать его в область глобального и наоборот.',
            'Тем не менее, вы можете использовать свой контролёр локального состояния, внутри глобального.'
        ]),

        textBlock([
            'Перед тем как нам перейти к знакомству с данной сущностью, следует отметить, что Micro Component не предопределяет ваше поведение при написании кода с использованием инструментов заранее, такая же ситуация и с глобальным состоянием. Вы можете писать на классах используя его контекст и оперируя экземплярами своих компонентов, можете создавать функциональные компоненты, как допустим - на примере данной документации.',
            'Не теряя ваше время будем приступать к изучению, и как всегда сначала объявим наш компонент и сразу объект State:'
        ]),

        codeBlock(
`const S = new MicroComponent({ mutateCSS: true, deleteNativeCSS: true }).use(['example.css']);

// Такое объект был создан для примера. Состояние может содержать просто примитив или еще более сложный объект.
const STATE = new State({
    text: 'Hello Global!',
    arrayList: [ 
        { text: 'Me', class: '.el_start' },
        { text: 'Me', class: '.el' },
        { text: 'Me', class: '.el_end' }
    ],
    settingElement: {
        class: '.class',
        css: { display: flex }
    }
});

// Так осуществляется работа с DOM:
// 1 параметр - контролёр объявленный выше
// 2 параметр - функция рендера элементов, должна вернуть HTMLElment | null | undefined, как свой параметр содержит актуальный объект состояния и меняет элементы внутри согласно актуальности объекта 
S(STATE, (state) => {
    return S('DIV', state.settingElement.class)
                .css(state.settingElement.css)
                .text(state.text)
                .append(
                    state.arrayList.map((el) => {
                        return return S('LI', el.class).text(el.text)
                    })
                )
});

`
,'js'
        ),

        textBlock([
            'Сразу стоит отметить, что при изменении STATE, элемент который будет возвращать обратная функция так же будет мутирован, что очень сильно может напоминать шаблонизацию в популярных решениях. Однако это не совсем так. По сути это изменённый объект локального состояния для поддержки инструментов рендера элементов, которые он контролирует. Чисто технически это означает, что тоже самое можно сделать с помощью локального состояния, однако, тут есть важный момент в позиции рендера элементов и если не вдаваться в техничские детали, отличия будут хорошо видны на переданном массиве элементов.',
            'В контейнере глобального состояния будет явно сделан акцент рендера на актуальные данные и элементы которые содержаться в state.arraylist, всегда будут равны элементам в DOM, в реализиции MCstate нам нужно будет вручную отчищать массив li элементов и заново напонять его данными, что влечёт за собой много кода и малую оптимизацию.',
            'Стоит так же отметить, что STATE может хранить больше одного узла ( в данном случае как и контролёр MCstate ), поэтому вы можете хранить разные блоки страниц в одном компоненте состояния или разделять логику по отображению компонентов, о чем мы подробнее поговорим дальше, сейчас нам нужно узнать, что контролёры могут отвечать не только за возврат актуальной стилизации как в MCstate, но и отдавать целые ветви DOM дерева. Конечно компоненты написанные на чистом JQuery внутри функции рендера тоже будут отображены и прекрасно работать.'
        ]),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('5.2 Контроль за элементами'),

        textBlock([
            'Сразу стоит отметить, что создавая глобальное состояние, то есть привязывая контролёр к функции которая это делает за вас, вы так же запоминаете этот элемент. Конечно имеется ввиду контролёр. Даже если элемент удалить со страницы, состояние будет помнить о нём, его позицию в DOM ( но удаление таких элементов через стандартные функции JQuery не является хорошей практикой ).',
            'Чтобы запомнить позицию, контролёр подмешает в ваше DOM дерево дополнительный элемент, чтобы понимать где он должен отрисовать настоящий, при необходимости.'
        ]),

        alertBlock('<micro_component>', [
            'При полном удалении элемента через функцию рендера, Micro Component гарантировано создат элемент micro_component с display: none. Это нужно чтобы он знал где находится элемент и в случае рендеринга элемента повторно, создать его на этом месте. Если вы решите удалить элемент со стороны, ошибки не будет. Элемент будет удалён, а последующие обращения к контролёру не будут рисовать элементы на этом месте, т.к. места для привязки не было задано заранее. Если вам нужно удалить элемент, но вы не можете получить доступ к объекту состояния, попробуйте воспользоваться глобальными функциями получения объектов, которые мы рассмотрим позже, если вам не хотелось бы получать дополнительных контролёров, вы можете избрать путь css и поставить элементу display: none',
        ]),

        textBlock([
            'В данном случае это проще показать на примере, но мы сразу рассмотрим то, с чем уже знакомились в разделе Локального состояния:'
        ]),

        codeBlock(
`//обратите внимание на состояние, оно тут пустое
const STATE = new State();

// Специально попробуем реализовать код внутри функции без применения Micro Component возможностей, для наглядности
S(STATE, (state) => {
    return $('<div>').addClass('test__class').append(
        $('<input>').attr('type', 'checkbox').attr('checked', state)
    );
}),
`,'js'
        ),
        
        textBlock([
            'Вы уже можете догадаться, что произойдет - элемент не будет отрендерен так как начальное состояние не было установлено, как и в локальном состоянии, но стоит обратить внимание на то о чем мы узнали выше и заглянуть в html:'
        ]),

        codeBlock(
`<micro_component style="height: 0; width: 0; display: none;"></micro_component>
`,'html'
        ),

        textBlock([
            'Как и было сказано, элемента на странице нет, но появилась сущность в HTML, так что фактически - есть, просто конкретно вашего элемента нет, и самого элемента мы не увидим.'
        ]),

        alertBlock('SEO', [
            'При разработке данного решения, был поднят вопрос о SEO оптимизации и элемент <micro_component> вероятно плохо под неё подходит, но при более детальном рассмотрении возникла проблема, что создание существующего в спецификации HTML элемента, может быть опасно в связи с выборками по элементам которые пользователи проектов могли делать ранее, и конечно css который вероятно мог бы быть привязан к элементам и переопределять их стили. Пожалуйста, специалисты по SEO, если наличие данного элемента может критично повредить алгоритмам поисковой машины, сообщите о проблеме в отведённом месте. Будет проведена работа в этом направлении.',
            'Пока решение с пометкой "временное".'
        ]),

        textBlock([
            'Теперь нам стоит только вызвать контролёр, и мы увидим наш элемент.'
        ]),

        codeBlock(
`//обратите внимание на состояние, оно тут пустое
const STATE = new State();

// через 2 секнунды, допустим пришли данные с запроса
setTimeout(() => {
    STATE.set(true);
},2000);

// Специально попробуем реализовать код внутри функции без применения Micro Component возможностей, для наглядности
S(STATE, (state) => {
    return $('<div>').addClass('test__class').append(
        $('<input>').attr('type', 'checkbox').attr('checked', state)
    );
}),
`,'js'
        ),

codeBlock(
`<div class="test__class">
    <input type="checkbox" checked="checked">
</div>`
,'html'
        ),

        textBlock([
            'Мы полностью заменили наш элемент данными, которые мы передавали в функцию рендера. Более того, теперь каждное новое вхождение в STATE будет изменять наши элементы исходя из изменённых данных, соответственно мы сделали с вами первый полноценный контролируемый узел HTML!'
        ]),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('5.3 Компонентный подход'),
        
        textBlock([
            'С тем что мы узнали, мы можем уже создавать незавимимые контейнеры которые будут работать внутри вашего уже написаного кода JQuery. Но с таким подходом мы можем пойти дальше, чтобы еще больше улучшить наш опыт разработки. Все что показано тут, может быть внедрено в ваш проект или стать основой для нового, поэтому не стесняйтесь эксперементировать.',
            'Давайте напишем то, что в современном мире Front-End разработки называют "Функциональный компонент" и сразу оговоримся, что отличия от иных решений будет в том, что мы с легкостью можем встроить такой компонент в уже наш существующий код проекта.',
            'И для наглядности, как когда-то мы опять возьмём какую-то условную задачу, чтобы на примере похожей на реальную задачу, мы смогли определить способы применения наших знаний о Micro Component и решить её.'
        ]),

        codeBlock(
`// Рассмотрите пожалуйста код, как пример.

// Инженеры бэкенда предоставили нам новый функционал, пока никак не влияющий на код в отображении.
$.ajax({
    url: './url/path/func.php',
    type: "GET"			
}).done(function (data) {})
.error((err) => {})


// Часть фронтенда которую нам предстоить переработать
$('.container').append(
    $('<p>').html('Очень важная часть страницы'),
    $('<div>').addClass('.class')
            .append(
                $('<span>').addClass('.text').html('Пожалуйста, заполните форму'),
                $('<form>')
                    .append(
                        $(<input>).attr('id', 'from_name').attr('type', 'text').attr('placeholder', 'name'),
                        $(<input>).attr('id', 'from_phone').attr('type', 'tel').attr('placeholder', 'phone')
                    ),
                $('<button>').on('click', () => {
                    $.ajax({
                        url: './url/path/send.php',
                        type: "POST",
                        data: {
                            name: $('#from_name').val(),
                            phone: $('#from_phone').val(),
                        }			
                    })
                })
            )
).appendTo('#wrapper');
`
,'js'
        ),

        textBlock([
            'Тут мы можем увидеть какой-то компонент с формой, давайте пока остановимся на этом коде, чтобы показать как мы можем решить следующую задачу:',
        ]),

        alertBlock('Задача', [
            'Пока идут данные, отобразим лоадер, при пришедших данных, где все формы NULL отобразить полную форму и сделать текст над ней красным, если какая-то часть формы пришла не как NULL, то мы не отображаем это поле ввода при этом меняем текст на "Дополните форму", цвет не меняем, а если пришло всё, то не отбражать форму, только текст с именем пользователя.'
        ]),

        textBlock([
            'уже представляете как решить эту задачу на чистом JQuery ? Или уже поняли как это сделать на Micro Component ? В любом случае, мы посмотрим как это сделать именно на Micro Component, а решение на чистом JQuery мы опустим, в связи с не желанием раздувания документации. Но если вы сможете сделать на JQuery более лаконичное и столь же ёмкое решение, то вы бы действительно поразили автора библиотеки! Давайте посмотрим что у нас получилось:'
        ]),

        codeBlock(
`// Рассмотрите пожалуйста код, как пример.

// Уже традиционная инициализация компонента.
const S = new MicroComponent({ mutateCSS: true, deleteNativeCSS: true }).use(['example.css']);


// Объявим необходимый контролёр, и наполним его данными которые нужны для инициализации
const FORM = new State({
    user: null,
    error: false,
    loading: true,
    formText: 'Пожалуйста, заполните форму',
    // тут можно сделать форму массивом и тогда перебором, просто дополняя этот объект расширять форму.
    // но пример с массивом уже имел место в этой документации, поэтому мы предоставим такой же с объектом.
    data: {
        name: null,
        phone: null
    }
});

// Теперь влияет, но как мы помним тут нет отображения.
$.ajax({
    url: './url/path/func.php',
    type: "GET"			
}).done(function (data) {
    const result = FORM.get();
    
    result.loading = false;
    // проверяем, может нам вообще нет смысла рисовать форму, исходя из условий задачи.
    if(data.name && data.phone) {
        result.user = data.name; 
        FORM.set(result);
        return;
    }

    // Тут что-то одно или всё равно null, присвоим в форму всё, а проверим рисовать или нет уже в отображении.
    result.data.name = data.name; // а тут мы доверимся инженерам бэкенда, но в реальном проекте желательно провести дополнительные проверки на пришедшие данные.
    result.data.phone = data.phone;

    // стоит проверить есть ли что-то, чтобы поменять текст
    if(result.data.name || result.data.phone) {
        formText = 'Дополните форму';
    }

    // отправили на отрисовку
    FORM.set(result);
}).error((err) => {
    const result = FORM.get();
    result.error = true;
    FORM.set(result);
});


// Часть фронтенда которую мы переработали
$('.container').append(
    $('<p>').html('Очень важная часть страницы'),
    // Cоздание контейнера с контролёром FORM 
    S(FORM, (form) => {
        
        if(from.error) {
            return $('<div>').addClass('error').html('Ошибка!');
        }


        if(form.loading === true) {
            return $('<div>').addClass('loader');
        }

        if(form.user) {
            return $('<div>').html(from.user);
        }

        const fields = {
            name: '',
            phone: '',
        };

        return $('<div>').addClass('.class')
            .append(
                $('<span>').addClass('.text').css({ color: !form.data.name && !form.data.phone ? red : black }).html(form.formText),
                $('<form>')
                    .append(
                        // Тут мы используем состояние полей, для их контролирования. 
                        // Этот материал мы рассмотрим далее, но самые внимательные уже заметили тут можно использовать рендер, можно в данном случае пропустим чтобы не усложнять пример. 
                        !form.data.name ? $(<input>).attr('id', 'from_name').attr('type', 'text').attr('placeholder', 'name').on('input', (e) => {
                            fields.name = e.target.value;
                        }) : null,
                        !form.data.phone ? $(<input>).attr('id', 'from_phone').attr('type', 'tel').attr('placeholder', 'phone').on('input', (e) => {
                            fields.phone = e.target.value;
                        }) : null
                    ),
                $('<button>').on('click', () => {
                    $.ajax({
                        url: './url/path/send.php',
                        type: "POST",
                        data: fields,
                    })
                })
            )
        )
    }).appendTo('#wrapper');
`
,'js'
        ),

        textBlock([
            'Не торопитесь в разборе кода, который вы видите как решение, там нет ничего сложного, вероятно присутствует непривычное.',
            'Самое главное что хотелось показать этим примером, что мы можем выходить на новый уровень абстракции не затрагивая уже существующей реализации, обратите внимание, что мы даже оставили атрибут ID в полях ввода, хотя они нам не нужны в этом случае мы просто стараемся не сломать то что уже было написано ( они уже могли бы быть где-то использованы ), так же хочу обратить внимание на избегание получения селекторов.'
        ]),

        alertBlock('Для начинающих', [
            'Тем кто еще мало работал с библиотекой jQuery или не работал с ней вовсе, стоит отметить, что создание контейнера с контролёром нужно для того, что бы мы могли обновлять код в нём по востребованию. Сама нативная разработка так НЕ работает в том числе и в связке с jQuery. При нативной разработке нам пришлось бы руками в запросе или допустим вызванной там функции, перерисовывать этот компонент руками.'
        ]),

        textBlock([
            'Это решение будет работать для нашей задачи, уже хорошо, но помимо этого оно обеспечило безопасный опыт взаимодействия с DOM и удобный способ организации обновления данной части веб страницы, тем не менее в Micro Component это будет считатся небольшой сущностью. Действительно вызывающе выглядит когда мы рендерим целые веб-страницы с помощью такого подхода.',
            'Они являются действительно интересными, так как там действительно получаются сложные структуры, из-за возможности вкладывать контролируемую область в другую контролируемую область.'
        ]),

        S(SPAN, ['.big_text_size', '.page_sub_title']).html('5.4 Основополагающий подход'),

        textBlock([
            'Такое определение он получил по причине создание полноценных компонентов, действительно больших частей веб-страниц или сразу целых страниц.',
            'Это, не смотря на размах уже не такая большая тема. В реальности подходы которые будут использованы в примерах ниже, уже были использованы ранее, а основные специфики работы остаются такими же. Есть ряд моментов с тем как оптимизировать рендеринг элементов, как создать структуру - но они все работают по тем же стандартам, поэтому возможно стоит только словесно описать их еще раз, продемонстрировать пример и поздравить вас с заключением изучения.',
            'В дальнейшем эта документация будет обрастать деталями, а этот текст который вы читаете скорее всего будет удалён. На этапе вашего ознакомления библиотека находится в тестовом режиме о чем вы могли ознакомиться на стартовой странице документации, тем не менее если вы уже попробывали или хотите использовать её в производственных целях - не переживайте. Функции которые у вас работают, будут работать так же, за исключением внутренних оптимизаций.',
            'Продолжим...'
        ]),

        alertBlock('Важно знать!', [
            'Как вы знаете, отрисовка элементов происходит после изменения контролёра. Поэтому зачастую часто обновляемые элементы стоит записать в отдельный контейнер с отдельным контролёром, чтобы обновлять конкретно его при необходимости.',
            'Тут важно соблюдать баланс между удобством использования и оптимизацией рендеринга.'
        ]),

        textBlock([
            'Давайте посмотрим на компонент такого рода:'
        ]),

    );
}